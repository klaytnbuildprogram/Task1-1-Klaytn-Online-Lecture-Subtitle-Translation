# Chapter 3 

## 3-1 Consensus

네 이전 강좌들을 통해 기존 블록체인 플랫폼들의 문제점을 다루어 보았는데요. 클레이튼 블록체인이 어떤 합의 알고리즘을 사용하여 문제점들을 해결하는 지에 대해서 이야기해보겠습니다. 합의 알고리즘의 종류는 여러가지가 있는데 보통 퍼블릭 블록체인에서 많이 사용하는 POW 나 POS , 그리고 프라이빗 블록체인에서 사용하는 PBFT 나 Raft 가 있습니다. 보통 프라이빗 블록체인이 퍼블릭 블록체인보다 더 효율적으로 합의에 도달할 수 있는데 특히 BFT 기반의 프라이빗 블록체인은 참여 노드의 수를 제한하여 높은 성능과 효율성을 달성할 수가 있습니다. 그러나 이러한 구성은 합의 노드수를 제한하며, 분산화를 약화시키고 합의 결과에 대한 내용이 소규모 그룹에게만 공개되기 때문에 투명성이 저하되고 블록체인 혜택을 의미있게 사용하지 못합니다. 

자 반면에 클레이튼은 BFT 의 성능 이점을 살려서 퍼블릭 블록체인의 장점과 결합할 수 있다는 믿음을 토대로 IBFT 를 합의 알고리즘으로 선택합니다. 강력한 보안 및 투명성을 유지하면서 엔터프라이즈급 성능 및 안정성을 제공하는 퍼블릭 블록체인이 지향하고 있고요. 이러한 목표를 달성하기 위해서 클레이튼은 공개를 통한 개인적인 합의 신뢰 모델을 채택하고 있습니다. 즉 합의를 달성하는 소수의 프라이빗한 노드들과 바깥에서 블록생성 결과를 공개적으로 접근 및 검증 할 수 있는 노드들로 구성되어있습니다. 네 이제 클레이튼에서 합의 알고리즘으로 사용하는 이스탄불 BFT 가 무엇인지 더 알아보도록 하겠습니다. 네 이스탄불 BFT 에서는 크게 세단계의 합의 과정에 있습니다. 프리프리페어, 프리페어, 그리고 커밋단계가 있는데요, 라운드 로빈 방식을 선택해서 매 라운드 마다 합의 노드들 중에 프로포절을 뽑습니다. 제안자라는 뜻이 있죠. 그리고 나머지 합의 노드들은 밸리데이터가 되요. 검증을 하게 되구요. 그림을 보시면 프로포저, 벨리데이터 1 2 3 이 다같은 합의 노드들이고요. 이중에 엑스표시가 되어있는 밸리데이터 3 노드가 현재 falt 한 상태. 즉 검증자로써 작동을 못하는 상태입니다. 컴퓨터가 고장났거나 네트워크가 끊어졋거나 또는 악의적으로 행동할 때를 말하구요. 네 첫번째 단계가 프로포즈라는 단계인데 이 단계에서 합의의 노드들 중에 한 노드가 프로포저 로 선택이 됩니다. 그리고 두번째 프리 프리페어 단게에서 프로포저 노드가 블록을 만들어서 다른 노드들에게 제안을 하게 되요. 자 여기보시면 밸리데이터 1 노드한테 보내고 2 노드한테 보내고 3 노드한테 보내죠. 이번에는 내가 제안하는 차례 이면서 이렇게 메세지와 함께 전달하는 단계입니다. 세번째 프리페어 단계에서 검증자 노드들이 벨리데이터 1 2 3 노드들이 프로포저한테 메세지를 받으면 자신을 제외한 다른 노드들에게 잘 받았다 라는 메세지를 보냅니다. 그래서 여기 보시면 밸리데이터 1 노드도 세군데에다가 보내고요, 밸리데이터 2 노드도 세군데에다가 보냅니다. 자 잘받았어 하면서 보내는 겁니다. 하지만 밸리데이터 3노드는 현재 falt 가 난 상태이기 때문에 아무것도 안보내고 계속 받기만 하는 상태이구요. 프리페어 상태가 이렇게 끝나면 시스템에서 총 몇개의 노드가 살아 있구나 하는 걸 알 수가 있어요. 이미지 같은 경우에는 프로포저 벨리데이터 1 벨리데이터 2 노드 해서 총 3개의 노드가 살아있다는 것을 알 수가 있죠. 이 과정을 검증자들이 모두 같은 라운드에 있는지 확인하는 겁니다. 마지막으로 커밋단게에서는 프로포저한테 보낸 블록을 수락할건지 다른 노드들과 소통하면서 결정하는 과정인데요. 예를 들어서 프로포저한테서 받은 블록이 괜찮다고 생각하는지 아니면 잘못되었다고 생각하는지 이렇게 각자 응답을 보냅니다. 만약 2/3이상이 합의를 했다고 계산하면 블록승인을 하고 곧바로 넘어가게 되는거구요. 결국에는 이 커밋단계에서 결정이 되고 파이널리티가 정리가 됩니다. 즉 파이널리티의 부재가 없고 변경불가능한 최종적인 상태가 이 스테이지에서 마무리가 되요. 비트코인이나 이더리움의 POW 처럼 애매모호한 상태가 아니라는 거죠. 자 그래서 장점은 합의 노드들끼리 통신을 통해 합의를 이끌어내고 그 즉시 완결성을 가집니다. 

하지만 그 합의 노드가 많아지면 많아질 수록 그만큼 통신량이 기하급수적으로 늘어난다는 단점도 있는데 이 부분은 합의 노드의 일부만 뽑아서 BFT  형태로 유지하게 설정되어있습니다. 

다음 강좌에서 좀 더 자세히 블록이 어떤 방식으로 생성되고 전파되는지 알아보도록 하겠습니다.


## 3-2 블록 생성 및 전파

네 클레이튼이 만족스러운 사용자 환경을 제공하기 위해 어떤 식으로 블록을 생성하고 전파하는지 알아보겠습니다. 먼저 블록 생성 사이클을 보도록 하죠. 

클레이튼에 블록 생성 주기를 라운드 라고 하는데, 각 라운드는 새로운 블록을 생성하고 끝나는 즉시 새로운 라운드가 시작이 됩니다. 블록 생성간격은 약 1초정도 걸린다고 보시면 되고요, 네. 제안자와 위원의 선택이 어떤 식으로 이루어지나 보겠습니다. 

각 라운드에서 블록을 생성할 제안자를 무작위지만 결정적으로 거버넌스 커운시 노드들중 하나를 뽑게 됩니다. 이 거버넌스 council 은 코어 셀들의 집합, 즉 합의의 노드들을 말하는 건데요. 자 여기 이미지를 보시면 각각의 동그라미들이 다 합의 노드들인데 그 중 파란색깔이 현재 라운드에 제안자로 선택이 된거에요. 그리고 해당 라운드에 위원회로 다른 합의 노드 그룹을 선택합니다. 그래서 핑크색깔이 지금 위원회로 뽑힌 벨리데이터 노드들 이고요. 

좀더 자세히 설명 드리자면, 각각의 합의 노드가 가장 최근에 블록헤더에서 파생된 난수를 사용하여 자기가 이 라운드에서 선택되었는지를 증명하게 되는 암호화 작업을 하게됩니다.

블록제안과 검증을 보겠습니다. 이 합의 노드가 제안자로써 선택이 되면 이 파란색이 제안자로써 선택이 됬어요. 그러면 자신이 그 라운드에서 제안자로 뽑힌 증거를 다른 합의 노드들에게 알리게 됩니다. 이때 어떤 증거를 대냐면 제안자의 공개키를 통해 입증 가능한 암호 증명을 쓰게 되구요. 그리고 나서 해당라운드에 위원으로 뽑힌 그룹은 제안자에게 자기들이 왜 위원회 멤버로 뽑혔는지 마찬가지로 증거와 함께 알려주게 됩니다. 이제 서로 누가 제안자이고 위원회인지 파악이 되면 제안자 같은 트랜잭션 풀에서 트랜잭션을 선택하고 정렬해서 블록을 만들게 되요. 그 후에 위원회와 합의를 하고 새로 생성된 블록에 동의하면 마무리를 짓게 됩니다. 

마지막으로 블록 전파를 알아보겠습니다. 제안된 블록은 성공적으로 완료되기 위해 위원회 멤버들의 2/3이상의 서명을 받아야 합니다. 위원회가 합의에 이르게 되면 새로운 블록이 모든 합의 노드 들에게 전달이 되고 그 합의 라운드는 끝이 납니다. 자 그렇게 되면 이제 프록시 노드를 통해 엔드 포인트 노드 들에게 블록을 전파할 수 있게 되고요. 

네 여기까지 어떤 식으로 제안자와 위원회가 선택이 되고 블록생성이 합의하며 전파가 되는지를 알아보았습니다.

## 3-3 네트워크 구조

네 클레이튼 네트워크 구조에 대해서 설명하는 시간을 갖도록 하겠습니다. 

네 왼쪽에 있는게 네트워크 축소판인데요, 전체 네트워크 안에 코어 셀 네트워크가 존재하고, 이 코어셀을 둘러싸는 엔드포인트 노드 네트워크가 존재합니다. 옆에 확대된걸 보시면 이 빨간 박스 안에 있는게 코어 셀 네트워크고, 바깥에 파란색이 엔드포인트 네트워크입니다. 코어셀 네트워크 안에 자세히 보시면 이 노란색 부분이 있죠. 이 노란색 부분은 CNN  컨센서스 노드 네트워크, 합의 노드 네트워크고 빨간색은 PNN , 프록시 노드 네트워크입니다. 노란색 안에 있는 CN 들이 합의를 담당하게 되는 노드들 이고요. 자 이 하나의 코어셀은 하나의 참여자가 운영을 하게 되는데 한개의 CN 과 또 이 CN 과 연결되어있는 여러개의 프록시 노드로 운영이 됩니다. CN 으로 참여하기 위해서는 까다로운 조건들을 갖춰야하고요. 그리고 이 CN 들은 자기네들끼리 계속 소통할 수 있도록 각자가 다 연결되어 있는 구조입니다. 만약 10대가 있으면 서로 다 연결되어 있는 거고요. 합의하는 과정에서 서로 최대한 빨리 커뮤니케이션을 해야하기 때문에 다 연결되어 있는 거에요. 

그리고 CN 들은 외부와는 직접적으로 접촉할 수가 없고요. 방해가 없는 굉장히 프라이빗한 환경이기 때문에 합의 노드로써 블록을 만드는 결정에 빨리 도달할 수 있는 장점이 있습니다. 

그러면 어떻게 접근하느냐, 바로 코어셀 참여자로써 자기가 운영하고 관리해서 믿을 수 있는 이 프록시 네트워크를 앞에 내세운다. 라는 컨셉입니다. 

자 바깥쪽에 보시면 엔드포인트 노드들이 이 코어셀 네트워크와 연결되어있죠. 이 엔드포인트 노드들이 코어셀안에 있는 프록시 노드와 연결해서 정보들을 주고받을 수 있습니다. 물론 엔드포인트 노드들끼리 서로 연결해서 정보를 주고받을 수도 있고요. 자 이렇게 서로 연결되어있죠. 하지만 엔드포인트 노드가 이 프록시 노드와 연결하면 더 빠르고 신속하게 신뢰도 높은 블록을 받을 수 있습니다. 이 엔드포인트 노드가 되기위한 조건은 없고요. 아무나 엔드포인트 노드가 되어서 웹이나 모바일같은 클라이언트들에게 정보를 전달할 수 가 있습니다. 서비스 제공자로써의 역할을 하는게 이 엔드포인트 노드입니다.

그리고 또 보시면 CN Boot node 와 PN Boot node, EN Boot node 가 있죠. 이 Boot node 는 새로 들어온 노드가 네트워크에 등록하고 또 다른 노드에 연결할 수 있도록 도움을 주는 클레이튼을 운영하는 특수 유형 노드입니다. CN boot node 는 CN 네트워크 안에 있으면서 공개가 되지않고 PN 와 EN boot node 는 공개가 됩니다. PN boot node 는 허용된 프록시 노드만 등록할 수 있게 해주고요. 엔드포인트 노드들과 또 연결할 수 있도록 도와줍니다. EN boot node는 어떤 프록시 노드에 연결해야될지, 엔드포인트 노드들에게 정보를 제공하는 역할을 하고요. 네 여기까지가 클레이튼 네트워크 구조에 대해서 간략하게 알아보았습니다.

## 3-4 코어셀

네 코어셀에대해서 좀더 자세히 이야기해보도록 하겠습니다. 합의를 담당하는 코어셀에서는 메인넷이 런칭되면 몇십대 정도로 운영이 될겁니다. 그리고 서비스가 잘 됨에 따라 코어셀의 연결하는 커넥션이 많아질 경우, 확장성 측면에서 어떻게 해야할까요? 

블록체인이 아닌 일반적인 경우 사용자가 늘어나면 서버를 늘리고 리퀘스트를 분할해서 처리하겠죠. 하지만 블록체인의 경우에는 노드를 늘려봤자 늘린만큼 정보를 각 노드들에게 더 전달해야되기 때문에 처리속도가 더 느려질 수 있습니다. 노드가 늘어난다고 노드의 성능이 늘어나지 않아요. 

그래서 노드의 수를 늘리기 보다는 그 노드 자체의 성능을 늘려야합니다. 예를 들어 램이나 CPU 의 성능을 더 높히는 거죠. 자 그러면 합의 노드로써 참여하기위한 조건들을 보겠습니다. 참여자가 가지고 있는 성능이 피지컬 코어가 40개 이상이고, 램이 256GB 고, 1년치의 데이터 약 14TB 를 저장할 수 있고 네트워크 10GB 이상이면 합의 노드로써 참여가 가능합니다. 참고로 참여자의 합의 노드들 중 하나의 성능이 특별히 좋다고 해서 코어셀의 네트워크가 빨라지는 것은 아닙니다. 성능이 더 나아진 나머지 노드들은 자기 스펙에 맞게 운영하고 있기 때문인데요. 그렇게 때문에 코어셀에 더 높은 성능 향상을 위해서는 전체가 다 똑같은 스펙에 맞춰서 성능향상을 시켜야합니다. 

자 코어셀의 구조를 다시 보시면 하나의 CN과 여러 대의 PN 으로 이루어져 있다는 것을 알 수 있죠. 이 PN이라는 프록시 노드가 왜 여러 대 있냐면 CN의 연결에 필요한 자원이 제한적이고 CN 역시 수가 한정되어있기 때문에 PN을 이용해서 이 엔드포인트에 연결을 지원하는거 에요. 예를 들어서 엔드포인트 노드들이 이 CN에 직접적으로 연결할 수 있다고 하겠습니다. 이 CN 이 엔드포인트 컨넥션을 1000개까지 허용할 수 있다 하면 그 이상 넘어가게 되면 CN으로써 부담이 되고 이상이 올 수 있겠죠. 그래서 PN이 그 역할을 대신해주는 겁니다. PN 이 엔드포인트 노드들과 연결하고 넘어온 트랜잭션들을 CN에 넘겨주는 거에요. 그리고 CN은 PN 몇대만 연결하면 되기 때문에 부담이 훨씬 덜 가고, 또 PN을 여러 대 둠으로써 코어셀에 연결하려는 엔드포인트 컨넥션 문제들을 해결할 수 있습니다. 

요약을 하자면 CN은 합의를 담당하는 노드기 때문에 컨넥션으로 인해 성능에 걸림돌이 되어서는 안되요. 그래서  PN 이 CN 을 보호해주는 역할이고 또 PN을 여러 대 둠으로써 확장성 문제도 해결할 수 있습니다.
